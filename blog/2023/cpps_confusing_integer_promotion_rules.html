<!DOCTYPE html>

<html lang="en-GB">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="initial-scale=1.0" />

    <title>Skifli Blogs | C++'s confusing integer promotion rules</title>
    <link rel="icon" type="image/png" href="https://avatars.githubusercontent.com/u/121291719">

    <link href="/assets/css/global.css" rel="stylesheet" />
    <link href="/assets/css/navbar.css" rel="stylesheet" />
    <link href="/assets/css/tags.css" rel="stylesheet" />

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css" />
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>

<body>
    <div id="nav">
        <div class="nav__list">
            <a href="/">Home</a>
            <a href="/projects">Projects</a>
            <a href="/stats">Stats</a>
            <a href="/blog" id="current">Blog</a>
        </div>
    </div>

    <div id="body">
        <h1 id="title">C++'s confusing integer promotion rules</h1>
        <div id="tags">
            <i>Tags: <b>C++</b>.</i>
        </div>

        <ul>
            <li><a href="#title" class="link">C++'s confusing integer promotion rules</a></li>
            <li><a href="#examples" class="link">Some Interesting Examples</a></li>
            <ul>
                <li><a href="#example-1" class="link">Example 1</a></li>
                <li><a href="#example-2" class="link">Example 2</a></li>
                <li><a href="#example-3" class="link">Example 3</a></li>
            </ul>
            <li><a href="#the-rules" class="link">The Rules</a></li>
            <li><a href="#summary" class="link">Summary</a></li>
        </ul>

        <br>

        <p>
            There are many parts of C++ that are not well understood, and lead to confusion. Two such aspects are the
            <i>usual arithmetic conversions</i> and the <i>integral promotions</i>. Some binary operators (e.g.
            arithmetic)
            require their operands to have a <i>common type</i>. The <i>usual arithmetic conversions</i> are the set of
            steps that converts operands into a common type. The <i>integral promotions</i> converts types smaller than
            int (or
            unsigned int) to either of those, depending on which can represent all the values of the original type. This
            is one of the many areas of C++ that are borrowed from C, and so the majority of the examples below apply to
            C as
            well.

            <br />
            <br />

            It would help if you had some understanding of <a
                href="https://en.cppreference.com/w/cpp/language/integer_literal" class="link" target="_blank">integer
                literals</a>, and the rules around what type integer literals will be.
        </p>

        <pre><code class="language-cpp">void main() {
    auto a = 1;   // Integer literal 1 has type int.
    auto b = 1U;  // Integer literal 1L has type unsigned int.
    auto c = 1L;  // Integer literal 1L has type long int.
    auto d = 1UL; // Integer literal 1UL has type unsigned long int.
}</code></pre>

        <h2 id="examples">Some Interesting Examples</h2>

        <p>It's quite likely that you won't be able to work out the behaviour of the code snippets. The examples are
            meant to be puzzling, and show some of the worst behaviours of C++.</p>

        <h3 id="example-1">Example 1</h3>

        <p>This snippet includes a <i>relational expression</i> between a <i>long</i> value and an <i>unsigned
                integer</i> value.</p>

        <pre><code class="language-cpp">void main() {
    std::cout << (-1L < 1U); // What will this output?
}</code></pre>

        <details>
            <summary>Output</summary>
            <ul>
                <li>Outputs 1 when using -m64 (LP64) compiler option.</li>
                <li>Outputs 0 when using -m32 (ILP32) compiler option.</li>
            </ul>
        </details>

        <h3 id="example-2">Example 2</h3>

        <p>This snippet includes subtraction between different <i>unsigned</i> variables.</p>

        <pre><code class="language-cpp">void main() {
    uint16_t a = 1;
    uint16_t b = 2;
    std::cout << a - b; // What will this output?            
}</code></pre>

        <details>
            <summary>Output</summary>
            <p>Outputs -1. How does a subtraction of two <i>unsigned types</i> result in a <i>signed type</i>?</p>
        </details>

        <pre><code class="language-cpp">void main() {
    uint32_t a = 1;
    uint32_t b = 2;
    std::cout << a - b; // What will this output?
}</code></pre>

        <details>
            <summary>Output</summary>
            <p>Outputs 4294967295. The wraparound is expected, but why a different result to when <i>uint16_t</i> is
                used?</p>
        </details>

        <p>
            Here, depending on whether we use <i>uint16_t</i> or <i>uint32_t</i>, we obtain different results for the
            same calculation. The most puzzling part is in the <i>uint16_t</i> case, where we receive a <i>signed</i>
            output,
            event though both operands are <i>unsigned</i>!
        </p>

        <h3 id="example-3">Example 3</h3>

        <pre><code class="language-cpp">void main() {
    unsigned short a=0xFFFF;
    unsigned short b=0xFFFF;
    std::cout << a * b; // What will this output?
}</code></pre>

        <details>
            <summary>Output</summary>
            <p>Using '-fsanitize=undefined' provides the following error:</p>
            <br />

            <p>
                runtime error: signed integer overflow: 65535 * 65535 cannot be represented in type 'int'
                <br />
                SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /main.cpp:1:1
            </p>
        </details>

        <h2 id="the-rules">The Rules</h2>

        <p>The rules for Usual Arithemtic Conversions are covered in the <a
                href="https://eel.is/c++draft/expr.arith.conv" class="link" target="_blank">draft C++ standard</a>. The
            section opens with the following paragraph:</p>

        <div class="citation">
            <p>
                Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield
                result types in a similar way. The purpose is to yield a common type, which is also the type of the
                result. This
                pattern is called the usual arithmetic conversions, which are defined as follows:
            </p>
        </div>

        <p>Let's have a look at each point. For each point, we will an example.</p>

        <ul>
            <li>If either operand is of scoped enumeration type, no conversions are performed; if the other operand does
                not have the same type, the expression is ill-formed.</li>
        </ul>

        <pre><code>enum class Enum1 {val1, val2};
enum class Enum2 {val1, val2};
    
void main() {
    auto val1 = Enum1::val1;
    auto val2 = Enum1::val2;

    auto val3 = Enum2::val1;
    auto val4 = Enum2::val2;

    val1 < val2; // Well-formed. Both operands have same type.
    val2 < val3; // Ill-formed. Operands have different types.
    val3 < 4;    // Ill-formed. Operands have different types.
}</code></pre>

        <ul>
            <li>If either operand is of type long double, the other shall be converted to long double.</li>
        </ul>

        <pre><code>void main() {
    long double a = 1;
    int b = 1;
    
    auto c = a + b; // b will be converted to long double.
}</code></pre>

        <ul>
            <li>Otherwise, if either operand is double, the other shall be converted to double.</li>
        </ul>

        <pre><code>void main() {
    double a = 1;
    int b = 1;
    
    auto c = a + b; // b will be converted to double.
}</code></pre>

        <ul>
            <li>Otherwise, if either operand is float, the other shall be converted to float.</li>
        </ul>

        <pre><code>void main() {
    float a = 1.0;
    int b = 1;
    
    auto c = a + b; // b will be converted to float.
}</code></pre>

        <p>
            So far, the results will probably have not seemed suprising. However, the next bullet deals with <i>integral
                promotions</i>, and what happens to the operands. There are several sub-bullets, and an example will be
            given for
            each.
        </p>

        <ul>
            <li>If both operands have the same type, no further conversion is needed.</li>
        </ul>

        <pre><code>void main() {
    char a = 1;
    short b = 1;
    
    auto c = a + b; // After integer promotions both operands promoted to int.
                    // Both have the same type so no further conversion needed.
}</code></pre>

        <ul>
            <li>Otherwise, if both operands have signed integer types or both have unsigned integer types, the operand
                with the type of lesser integer conversion rank shall be converted to the type of the operand with
                greater rank.</li>
        </ul>

        <pre><code>void main() {
    int a = 1;
    long b = 1;

    auto c = a + b; // After integer promotions, 'a' remains int and 'b' remains
                    // long. Both are signed, but int has a rank less than long
                    // so 'a' will be converted to long.

    unsigned int d = 1;
    unsigned long e = 1;

    auto f = d + e; // After integer promotions, 'd' remains unsigned int,
                    // 'e' remains unsigned long. Both are unsigned, but
                    // unsigned int has a rank less than unsigned long so
                    // 'd' will be converted to unsigned long.
}</code></pre>

        <ul>
            <li>
                Otherwise, if the operand that has unsigned integer type has rank greater than or equal to the rank of
                the type of the other operand, the operand with signed integer type shall be converted to the type of
                the operand
                with unsigned integer type.
            </li>
        </ul>

        <pre><code>void main() {
    auto bigger = 1U >
                    -1; // Integer promotions does not affect the types of the
                        // operands. unsigned int has a rank greater than or equal
                        // to int. So, the right operand will be converted to
                        // unsigned int. That means we have 1U > -1U, which is
                        // equivalent to 1U > 4294967295U, which is false.
}</code></pre>

        <ul>
            <li>
                Otherwise, if the type of the operand with signed integer type can represent all of the values of the
                type of the operand with unsigned integer type, the operand with unsigned integer type shall be
                converted to the type
                of the operand with signed integer type.
            </li>
            <li>Otherwise, both operands shall be converted to the unsigned integer type corresponding to the type of
                the operand with signed integer type.</li>
        </ul>

        <pre><code>void main() {
    std::cout
        << (-1L <
            1U); // Integer promotions does not affect the types of
                    // the operands.
                    //
                    // On a LP64 system, long can
                    // represent all the values of unsigned int, so 1U
                    // will be converted to long. So we have -1L < 1L, which is
                    // true.
                    //
                    // On an ILP32 system, long can not represent all the
                    // values of unsigned int, so unsigned int and long will be
                    // converted to unsigned long, which is the unsigned integer
                    // type corresponding to the type of signed operand (long).
                    //
                    // So we have -1UL < 1UL, which is equivalent to 4294967295UL <
                    // 1UL, which is false.
                    //
                    // https://stackoverflow.com/a/22801135/1708801 explains why
                    // -1UL becomes 4294967295UL.
}</code></pre>

        <h2 id="summary">Summary</h2>

        <p>In this blog we have learnt about <i>usual arithmetic conversions</i>, and how they bring operands of many
            binary operations to a common type before evaluation. We saw several examples, and looked at their
            behaviour. We have also seen how results can vary based on the host platform. Here is a summary of the blog:
        </p>

        <ul>
            <li>When we mix <i>signed</i> and <i>unsigned</i> types, a conversion to one of these types will be
                required. Working out what conversion occurs, and applying the conversion explicitly, may help prevent
                confusion.</li>
            <li>When dealing with <i>integral</i> types smaller then <i>int</i> and <i>unsigned int</i>, the integral
                promotions will require a conversion to a larger type. These can lead to changes in sign, and so it may
                make sense to apply the conversion explicitly.</li>
            <li>Mixing <i>signed</i> and <i>unsigned</i> types in <i>relational expressions</i> can lead to unintuitive
                results, due to changes in sign.</li>
            <li>Arithmetic on <i>unsigned</i> values never leads to undefined behavior, but arithemtic on <i>signed</i>
                values can, if the result overflows.</li>
        </ul>
    </div>

    <script>
        hljs.highlightAll();
    </script>
</body>

</html>